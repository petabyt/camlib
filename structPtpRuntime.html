<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>camlib: PtpRuntime Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">camlib
   </div>
   <div id="projectbrief">Documentation for camlib is still a work-in-progress</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structPtpRuntime-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PtpRuntime Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Holds all camlib instance info.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="camlib_8h_source.html">camlib.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4684ca0e83e0459c7d039087f045ef6f" id="r_a4684ca0e83e0459c7d039087f045ef6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4684ca0e83e0459c7d039087f045ef6f">ptp_get_return_code</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:a4684ca0e83e0459c7d039087f045ef6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the return code (RC) currently in the data buffer.  <br /></td></tr>
<tr class="separator:a4684ca0e83e0459c7d039087f045ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34187785d86801a9fb4ccfac95c2b031" id="r_a34187785d86801a9fb4ccfac95c2b031"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34187785d86801a9fb4ccfac95c2b031">ptp_get_param_length</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:a34187785d86801a9fb4ccfac95c2b031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of parameters in packet in data buffer.  <br /></td></tr>
<tr class="separator:a34187785d86801a9fb4ccfac95c2b031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff70238e2dd5babd15b60d030f3febe" id="r_acff70238e2dd5babd15b60d030f3febe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acff70238e2dd5babd15b60d030f3febe">ptp_get_param</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int i)</td></tr>
<tr class="memdesc:acff70238e2dd5babd15b60d030f3febe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parameter at index i.  <br /></td></tr>
<tr class="separator:acff70238e2dd5babd15b60d030f3febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c195e74507973ca1a0350686d24b48" id="r_a86c195e74507973ca1a0350686d24b48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86c195e74507973ca1a0350686d24b48">ptp_get_last_transaction_id</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:a86c195e74507973ca1a0350686d24b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get transaction ID of packet in the data buffer.  <br /></td></tr>
<tr class="separator:a86c195e74507973ca1a0350686d24b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fdb25285ca30f1ca7614f416edad13" id="r_a82fdb25285ca30f1ca7614f416edad13"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82fdb25285ca30f1ca7614f416edad13">ptp_get_payload</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:a82fdb25285ca30f1ca7614f416edad13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ptr of packet payload in data buffer, after packet header.  <br /></td></tr>
<tr class="separator:a82fdb25285ca30f1ca7614f416edad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bfd0417dabf76cae794215a4189b6c" id="r_a80bfd0417dabf76cae794215a4189b6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80bfd0417dabf76cae794215a4189b6c">ptp_get_payload_length</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:a80bfd0417dabf76cae794215a4189b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length of payload returned by ptp_get_payload.  <br /></td></tr>
<tr class="separator:a80bfd0417dabf76cae794215a4189b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ea9521e71a938fe5044153af439b7b" id="r_a04ea9521e71a938fe5044153af439b7b"><td class="memItemLeft" align="right" valign="top"><a id="a04ea9521e71a938fe5044153af439b7b" name="a04ea9521e71a938fe5044153af439b7b"></a>
struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_new</b> (int options)</td></tr>
<tr class="memdesc:a04ea9521e71a938fe5044153af439b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new <a class="el" href="structPtpRuntime.html" title="Holds all camlib instance info.">PtpRuntime</a> based on bitfield options - see PtpConnType. <br /></td></tr>
<tr class="separator:a04ea9521e71a938fe5044153af439b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f04daa3a557f761a6413b05dc7bb7b3" id="r_a1f04daa3a557f761a6413b05dc7bb7b3"><td class="memItemLeft" align="right" valign="top"><a id="a1f04daa3a557f761a6413b05dc7bb7b3" name="a1f04daa3a557f761a6413b05dc7bb7b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_reset</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:a1f04daa3a557f761a6413b05dc7bb7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all session-specific fields of <a class="el" href="structPtpRuntime.html" title="Holds all camlib instance info.">PtpRuntime</a> - both libusb and libwpd backends call this before establishing connection, so calling this is not required. <br /></td></tr>
<tr class="separator:a1f04daa3a557f761a6413b05dc7bb7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b732f6e2c304199c07807323d7baac" id="r_a65b732f6e2c304199c07807323d7baac"><td class="memItemLeft" align="right" valign="top"><a id="a65b732f6e2c304199c07807323d7baac" name="a65b732f6e2c304199c07807323d7baac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_init</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:a65b732f6e2c304199c07807323d7baac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init <a class="el" href="structPtpRuntime.html" title="Holds all camlib instance info.">PtpRuntime</a> locally - uses default recommended settings (USB) <br /></td></tr>
<tr class="separator:a65b732f6e2c304199c07807323d7baac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378d9504c871c190fb65357e6d580066" id="r_a378d9504c871c190fb65357e6d580066"><td class="memItemLeft" align="right" valign="top"><a id="a378d9504c871c190fb65357e6d580066" name="a378d9504c871c190fb65357e6d580066"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_close</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:a378d9504c871c190fb65357e6d580066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees <a class="el" href="structPtpRuntime.html" title="Holds all camlib instance info.">PtpRuntime</a> data buffer - doesn't free the actual structure, or device info (yet) <br /></td></tr>
<tr class="separator:a378d9504c871c190fb65357e6d580066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b05005f4add36b980e0aa5099eb381b" id="r_a5b05005f4add36b980e0aa5099eb381b"><td class="memItemLeft" align="right" valign="top"><a id="a5b05005f4add36b980e0aa5099eb381b" name="a5b05005f4add36b980e0aa5099eb381b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_send</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, struct <a class="el" href="structPtpCommand.html">PtpCommand</a> *cmd)</td></tr>
<tr class="memdesc:a5b05005f4add36b980e0aa5099eb381b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command request to the device with no data phase. <br /></td></tr>
<tr class="separator:a5b05005f4add36b980e0aa5099eb381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33813c63d683fbaf32c9a5ac0b35968e" id="r_a33813c63d683fbaf32c9a5ac0b35968e"><td class="memItemLeft" align="right" valign="top"><a id="a33813c63d683fbaf32c9a5ac0b35968e" name="a33813c63d683fbaf32c9a5ac0b35968e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_send_data</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, struct <a class="el" href="structPtpCommand.html">PtpCommand</a> *cmd, void *<a class="el" href="#a7f23f0512393ff28362cd8cbf7d7d71e">data</a>, int length)</td></tr>
<tr class="memdesc:a33813c63d683fbaf32c9a5ac0b35968e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command request to the device with a data phase (thread safe) <br /></td></tr>
<tr class="separator:a33813c63d683fbaf32c9a5ac0b35968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e33de856b2118fe5575e0fdde30cbd3" id="r_a3e33de856b2118fe5575e0fdde30cbd3"><td class="memItemLeft" align="right" valign="top"><a id="a3e33de856b2118fe5575e0fdde30cbd3" name="a3e33de856b2118fe5575e0fdde30cbd3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_get_event</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, struct PtpEventContainer *ec)</td></tr>
<tr class="memdesc:a3e33de856b2118fe5575e0fdde30cbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try and get an event from the camera over int endpoint (USB-only) <br /></td></tr>
<tr class="separator:a3e33de856b2118fe5575e0fdde30cbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefec40a1a3fb4ad24414d51e22c11701" id="r_aefec40a1a3fb4ad24414d51e22c11701"><td class="memItemLeft" align="right" valign="top"><a id="aefec40a1a3fb4ad24414d51e22c11701" name="aefec40a1a3fb4ad24414d51e22c11701"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_mutex_unlock</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:aefec40a1a3fb4ad24414d51e22c11701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the IO mutex (unless it was kept locked) <br /></td></tr>
<tr class="separator:aefec40a1a3fb4ad24414d51e22c11701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24a3ce43b4f53f37731bd03d9735129" id="r_aa24a3ce43b4f53f37731bd03d9735129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa24a3ce43b4f53f37731bd03d9735129">ptp_mutex_keep_locked</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:aa24a3ce43b4f53f37731bd03d9735129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep the mutex locked one more time for the current thread.  <br /></td></tr>
<tr class="separator:aa24a3ce43b4f53f37731bd03d9735129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67c5de195afa6e1a456d1ad4d148e40" id="r_aa67c5de195afa6e1a456d1ad4d148e40"><td class="memItemLeft" align="right" valign="top"><a id="aa67c5de195afa6e1a456d1ad4d148e40" name="aa67c5de195afa6e1a456d1ad4d148e40"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_mutex_lock</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:aa67c5de195afa6e1a456d1ad4d148e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the IO mutex - only should be used by backend. <br /></td></tr>
<tr class="separator:aa67c5de195afa6e1a456d1ad4d148e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ec006631ba510bd761704bb6e1603d" id="r_af1ec006631ba510bd761704bb6e1603d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1ec006631ba510bd761704bb6e1603d">ptp_device_type</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:af1ec006631ba510bd761704bb6e1603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets type of device from r-&gt;di.  <br /></td></tr>
<tr class="separator:af1ec006631ba510bd761704bb6e1603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6ae466c463c890efb88a377cb7cf82" id="r_adc6ae466c463c890efb88a377cb7cf82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc6ae466c463c890efb88a377cb7cf82">ptp_check_opcode</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int opcode)</td></tr>
<tr class="memdesc:adc6ae466c463c890efb88a377cb7cf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an opcode is supported by looking through supported props in r-&gt;di.  <br /></td></tr>
<tr class="separator:adc6ae466c463c890efb88a377cb7cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593667104ac08ecfba4b8860f83941ec" id="r_a593667104ac08ecfba4b8860f83941ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a593667104ac08ecfba4b8860f83941ec">ptp_check_prop</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int code)</td></tr>
<tr class="memdesc:a593667104ac08ecfba4b8860f83941ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a property code is supported by looking through supported props in r-&gt;di.  <br /></td></tr>
<tr class="separator:a593667104ac08ecfba4b8860f83941ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f65b693efaf4fc67b7837a312dfdd6" id="r_ac2f65b693efaf4fc67b7837a312dfdd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2f65b693efaf4fc67b7837a312dfdd6">ptp_buffer_resize</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, size_t size)</td></tr>
<tr class="memdesc:ac2f65b693efaf4fc67b7837a312dfdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mostly for internal use - realloc the data buffer.  <br /></td></tr>
<tr class="separator:ac2f65b693efaf4fc67b7837a312dfdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14deac23d2f24cc1188c499a1255e5f9" id="r_a14deac23d2f24cc1188c499a1255e5f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14deac23d2f24cc1188c499a1255e5f9">ptp_set_generic_property</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, const char *name, int value)</td></tr>
<tr class="memdesc:a14deac23d2f24cc1188c499a1255e5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a generic property - abstraction over SetDeviceProp.  <br /></td></tr>
<tr class="separator:a14deac23d2f24cc1188c499a1255e5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa317218a1bbbd18bc3b20ae9db1624f9" id="r_aa317218a1bbbd18bc3b20ae9db1624f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa317218a1bbbd18bc3b20ae9db1624f9">ptp_pre_take_picture</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:aa317218a1bbbd18bc3b20ae9db1624f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call before taking a picture - this is generally for 'focusing' On some cameras this does nothing.  <br /></td></tr>
<tr class="separator:aa317218a1bbbd18bc3b20ae9db1624f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace66256ef8a5a751e1b1bdf38787aa1" id="r_aace66256ef8a5a751e1b1bdf38787aa1"><td class="memItemLeft" align="right" valign="top"><a id="aace66256ef8a5a751e1b1bdf38787aa1" name="aace66256ef8a5a751e1b1bdf38787aa1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_take_picture</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:aace66256ef8a5a751e1b1bdf38787aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call after calling ptp_pre_take_picture - this time a picture will be taken. <br /></td></tr>
<tr class="separator:aace66256ef8a5a751e1b1bdf38787aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f078ea0df6b7f09bba6af0643f10b5" id="r_ac1f078ea0df6b7f09bba6af0643f10b5"><td class="memItemLeft" align="right" valign="top"><a id="ac1f078ea0df6b7f09bba6af0643f10b5" name="ac1f078ea0df6b7f09bba6af0643f10b5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_open_session</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="memdesc:ac1f078ea0df6b7f09bba6af0643f10b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a new session - required for most commands. <br /></td></tr>
<tr class="separator:ac1f078ea0df6b7f09bba6af0643f10b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8f6f64887e4a2848903e863f8afe72" id="r_acf8f6f64887e4a2848903e863f8afe72"><td class="memItemLeft" align="right" valign="top"><a id="acf8f6f64887e4a2848903e863f8afe72" name="acf8f6f64887e4a2848903e863f8afe72"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_close_session</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="separator:acf8f6f64887e4a2848903e863f8afe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9f29703ccabe8b832ba07e2076f908" id="r_a8f9f29703ccabe8b832ba07e2076f908"><td class="memItemLeft" align="right" valign="top"><a id="a8f9f29703ccabe8b832ba07e2076f908" name="a8f9f29703ccabe8b832ba07e2076f908"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_get_device_info</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, struct PtpDeviceInfo *<a class="el" href="#ad6e7184353de80d51e6f975c7085ffe2">di</a>)</td></tr>
<tr class="separator:a8f9f29703ccabe8b832ba07e2076f908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81a7d45b24e770e249f03e8e991aee8" id="r_aa81a7d45b24e770e249f03e8e991aee8"><td class="memItemLeft" align="right" valign="top"><a id="aa81a7d45b24e770e249f03e8e991aee8" name="aa81a7d45b24e770e249f03e8e991aee8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_init_capture</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int storage_id, int object_format)</td></tr>
<tr class="separator:aa81a7d45b24e770e249f03e8e991aee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1216f58897e6ca35124a58c7f9758e" id="r_a2d1216f58897e6ca35124a58c7f9758e"><td class="memItemLeft" align="right" valign="top"><a id="a2d1216f58897e6ca35124a58c7f9758e" name="a2d1216f58897e6ca35124a58c7f9758e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_init_open_capture</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int storage_id, int object_format)</td></tr>
<tr class="separator:a2d1216f58897e6ca35124a58c7f9758e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac820409424e3de810ecbdc39d0a0b144" id="r_ac820409424e3de810ecbdc39d0a0b144"><td class="memItemLeft" align="right" valign="top"><a id="ac820409424e3de810ecbdc39d0a0b144" name="ac820409424e3de810ecbdc39d0a0b144"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_terminate_open_capture</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int trans)</td></tr>
<tr class="separator:ac820409424e3de810ecbdc39d0a0b144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019e88d5f344b9f0905801e54c6b4b1f" id="r_a019e88d5f344b9f0905801e54c6b4b1f"><td class="memItemLeft" align="right" valign="top"><a id="a019e88d5f344b9f0905801e54c6b4b1f" name="a019e88d5f344b9f0905801e54c6b4b1f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_get_storage_info</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int id, struct PtpStorageInfo *si)</td></tr>
<tr class="separator:a019e88d5f344b9f0905801e54c6b4b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935dcfc1df1871caf21ae26f7508c62a" id="r_a935dcfc1df1871caf21ae26f7508c62a"><td class="memItemLeft" align="right" valign="top"><a id="a935dcfc1df1871caf21ae26f7508c62a" name="a935dcfc1df1871caf21ae26f7508c62a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_send_object_info</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int storage_id, int handle, struct PtpObjectInfo *oi)</td></tr>
<tr class="separator:a935dcfc1df1871caf21ae26f7508c62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e392052808ce00f4e463c3c35f824b" id="r_ac4e392052808ce00f4e463c3c35f824b"><td class="memItemLeft" align="right" valign="top"><a id="ac4e392052808ce00f4e463c3c35f824b" name="ac4e392052808ce00f4e463c3c35f824b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_get_prop_value</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int code)</td></tr>
<tr class="separator:ac4e392052808ce00f4e463c3c35f824b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dbbd00763b8b3c3f7fa9f585e68462" id="r_a29dbbd00763b8b3c3f7fa9f585e68462"><td class="memItemLeft" align="right" valign="top"><a id="a29dbbd00763b8b3c3f7fa9f585e68462" name="a29dbbd00763b8b3c3f7fa9f585e68462"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_set_prop_value</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int code, int value)</td></tr>
<tr class="separator:a29dbbd00763b8b3c3f7fa9f585e68462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9665bd77daba7e3bcba02e9876e174be" id="r_a9665bd77daba7e3bcba02e9876e174be"><td class="memItemLeft" align="right" valign="top"><a id="a9665bd77daba7e3bcba02e9876e174be" name="a9665bd77daba7e3bcba02e9876e174be"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_set_prop_value_data</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int code, void *<a class="el" href="#a7f23f0512393ff28362cd8cbf7d7d71e">data</a>, int length)</td></tr>
<tr class="separator:a9665bd77daba7e3bcba02e9876e174be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df861658fefb547a48fd77a8c4983a9" id="r_a0df861658fefb547a48fd77a8c4983a9"><td class="memItemLeft" align="right" valign="top"><a id="a0df861658fefb547a48fd77a8c4983a9" name="a0df861658fefb547a48fd77a8c4983a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_get_prop_desc</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int code, struct PtpPropDesc *pd)</td></tr>
<tr class="separator:a0df861658fefb547a48fd77a8c4983a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09031095738de83df9db2c0bc358f92" id="r_ad09031095738de83df9db2c0bc358f92"><td class="memItemLeft" align="right" valign="top"><a id="ad09031095738de83df9db2c0bc358f92" name="ad09031095738de83df9db2c0bc358f92"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_get_object_handles</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int id, int format, int in, struct <a class="el" href="structPtpArray.html">PtpArray</a> **a)</td></tr>
<tr class="memdesc:ad09031095738de83df9db2c0bc358f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of object handles in a storage device or folder. <br /></td></tr>
<tr class="separator:ad09031095738de83df9db2c0bc358f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33df534a00c0d1d46c54253c675daded" id="r_a33df534a00c0d1d46c54253c675daded"><td class="memItemLeft" align="right" valign="top"><a id="a33df534a00c0d1d46c54253c675daded" name="a33df534a00c0d1d46c54253c675daded"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_get_object_info</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, uint32_t handle, struct PtpObjectInfo *oi)</td></tr>
<tr class="separator:a33df534a00c0d1d46c54253c675daded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a84a1fd879b66442b9ae571077b5bd" id="r_ae4a84a1fd879b66442b9ae571077b5bd"><td class="memItemLeft" align="right" valign="top"><a id="ae4a84a1fd879b66442b9ae571077b5bd" name="ae4a84a1fd879b66442b9ae571077b5bd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_move_object</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int storage_id, int handle, int folder)</td></tr>
<tr class="separator:ae4a84a1fd879b66442b9ae571077b5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9eaa7bf7d47741b46be439a4f01fb7" id="r_afd9eaa7bf7d47741b46be439a4f01fb7"><td class="memItemLeft" align="right" valign="top"><a id="afd9eaa7bf7d47741b46be439a4f01fb7" name="afd9eaa7bf7d47741b46be439a4f01fb7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_delete_object</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int handle, int format_code)</td></tr>
<tr class="separator:afd9eaa7bf7d47741b46be439a4f01fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1349640be24b23301f82338a4e89202e" id="r_a1349640be24b23301f82338a4e89202e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1349640be24b23301f82338a4e89202e">ptp_get_thumbnail</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int handle)</td></tr>
<tr class="memdesc:a1349640be24b23301f82338a4e89202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw JPEG data is accessible from <a class="el" href="#a82fdb25285ca30f1ca7614f416edad13" title="Get ptr of packet payload in data buffer, after packet header.">ptp_get_payload()</a>  <br /></td></tr>
<tr class="separator:a1349640be24b23301f82338a4e89202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1730ddab297b7c9f0a7619bf4f379571" id="r_a1730ddab297b7c9f0a7619bf4f379571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1730ddab297b7c9f0a7619bf4f379571">ptp_get_partial_object</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, uint32_t handle, int offset, int max)</td></tr>
<tr class="separator:a1730ddab297b7c9f0a7619bf4f379571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a74dc474f1a9f03242a1ac689875ca" id="r_ab2a74dc474f1a9f03242a1ac689875ca"><td class="memItemLeft" align="right" valign="top"><a id="ab2a74dc474f1a9f03242a1ac689875ca" name="ab2a74dc474f1a9f03242a1ac689875ca"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_get_object</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int handle)</td></tr>
<tr class="memdesc:ab2a74dc474f1a9f03242a1ac689875ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download an object. <br /></td></tr>
<tr class="separator:ab2a74dc474f1a9f03242a1ac689875ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a3a5f00b93263321de0080a9bfb639" id="r_a39a3a5f00b93263321de0080a9bfb639"><td class="memItemLeft" align="right" valign="top"><a id="a39a3a5f00b93263321de0080a9bfb639" name="a39a3a5f00b93263321de0080a9bfb639"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ptp_download_object</b> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, int handle, FILE *stream, size_t max)</td></tr>
<tr class="memdesc:a39a3a5f00b93263321de0080a9bfb639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download an object from handle, to a local file (uses GetPartialObject) <br /></td></tr>
<tr class="separator:a39a3a5f00b93263321de0080a9bfb639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d253bf202fa9823e1d49fb016f541f" id="r_ae0d253bf202fa9823e1d49fb016f541f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0d253bf202fa9823e1d49fb016f541f">ptp_get_all_known</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, struct <a class="el" href="structPtpGenericEvent.html">PtpGenericEvent</a> **s, int *length)</td></tr>
<tr class="memdesc:ae0d253bf202fa9823e1d49fb016f541f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recieve a generic list of all properties received in DeviceInfo This is similar to getting all events, but for first startup when you know nothing. Some vendors do this, but this gets all the properties manually.  <br /></td></tr>
<tr class="separator:ae0d253bf202fa9823e1d49fb016f541f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab71c60e32fb92e3c5458431006c57da" id="r_aab71c60e32fb92e3c5458431006c57da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab71c60e32fb92e3c5458431006c57da">ptpip_init_events</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r)</td></tr>
<tr class="separator:aab71c60e32fb92e3c5458431006c57da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608fc909a1d17cf3e8ad39b261c994bf" id="r_a608fc909a1d17cf3e8ad39b261c994bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a608fc909a1d17cf3e8ad39b261c994bf">ptpip_init_command_request</a> (struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *r, char *device_name)</td></tr>
<tr class="separator:a608fc909a1d17cf3e8ad39b261c994bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a295b65c4bba2f26117c04c041c5b48ab" id="r_a295b65c4bba2f26117c04c041c5b48ab"><td class="memItemLeft" align="right" valign="top"><a id="a295b65c4bba2f26117c04c041c5b48ab" name="a295b65c4bba2f26117c04c041c5b48ab"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>io_kill_switch</b></td></tr>
<tr class="memdesc:a295b65c4bba2f26117c04c041c5b48ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to 1 to kill all IO operations. By default, this is 1. When a valid connection is achieved by libusb, libwpd, and tcp backends, it will be set to 0. On IO error, it will be set to 1. <br /></td></tr>
<tr class="separator:a295b65c4bba2f26117c04c041c5b48ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed36a8eae0146cdb13a2fb5e7ca201a0" id="r_aed36a8eae0146cdb13a2fb5e7ca201a0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed36a8eae0146cdb13a2fb5e7ca201a0">connection_type</a></td></tr>
<tr class="memdesc:aed36a8eae0146cdb13a2fb5e7ca201a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of enum PtpConnType.  <br /></td></tr>
<tr class="separator:aed36a8eae0146cdb13a2fb5e7ca201a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e655ea665c46fd29ff029924d63e7fa" id="r_a9e655ea665c46fd29ff029924d63e7fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e655ea665c46fd29ff029924d63e7fa">transaction</a></td></tr>
<tr class="separator:a9e655ea665c46fd29ff029924d63e7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae65285b4aad1dfe6e5329924f269adf" id="r_aae65285b4aad1dfe6e5329924f269adf"><td class="memItemLeft" align="right" valign="top"><a id="aae65285b4aad1dfe6e5329924f269adf" name="aae65285b4aad1dfe6e5329924f269adf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>session</b></td></tr>
<tr class="separator:aae65285b4aad1dfe6e5329924f269adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f23f0512393ff28362cd8cbf7d7d71e" id="r_a7f23f0512393ff28362cd8cbf7d7d71e"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f23f0512393ff28362cd8cbf7d7d71e">data</a></td></tr>
<tr class="memdesc:a7f23f0512393ff28362cd8cbf7d7d71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global buffer for data reading and writing.  <br /></td></tr>
<tr class="separator:a7f23f0512393ff28362cd8cbf7d7d71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca3bc643084556785ca656fd96e90be" id="r_a7ca3bc643084556785ca656fd96e90be"><td class="memItemLeft" align="right" valign="top"><a id="a7ca3bc643084556785ca656fd96e90be" name="a7ca3bc643084556785ca656fd96e90be"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>data_length</b></td></tr>
<tr class="separator:a7ca3bc643084556785ca656fd96e90be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab07e398c60b4ca2c53a84e653a9bdec" id="r_aab07e398c60b4ca2c53a84e653a9bdec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab07e398c60b4ca2c53a84e653a9bdec">max_packet_size</a></td></tr>
<tr class="separator:aab07e398c60b4ca2c53a84e653a9bdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e7184353de80d51e6f975c7085ffe2" id="r_ad6e7184353de80d51e6f975c7085ffe2"><td class="memItemLeft" align="right" valign="top">struct PtpDeviceInfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6e7184353de80d51e6f975c7085ffe2">di</a></td></tr>
<tr class="memdesc:ad6e7184353de80d51e6f975c7085ffe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Info about current connection, used to detect camera type, supported opodes, etc.  <br /></td></tr>
<tr class="separator:ad6e7184353de80d51e6f975c7085ffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211e18fbaa2c3b218a2addc054e3e4a9" id="r_a211e18fbaa2c3b218a2addc054e3e4a9"><td class="memItemLeft" align="right" valign="top"><a id="a211e18fbaa2c3b218a2addc054e3e4a9" name="a211e18fbaa2c3b218a2addc054e3e4a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>device_type</b></td></tr>
<tr class="separator:a211e18fbaa2c3b218a2addc054e3e4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6907846454805fb1cec573aafe65e4" id="r_aba6907846454805fb1cec573aafe65e4"><td class="memItemLeft" align="right" valign="top"><a id="aba6907846454805fb1cec573aafe65e4" name="aba6907846454805fb1cec573aafe65e4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>data_phase_length</b></td></tr>
<tr class="memdesc:aba6907846454805fb1cec573aafe65e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For Windows compatibility, this is set to indicate lenth for a data packet that will be sent after a command packet. Will be set to zero when ptp_send_bulk_packets is called. <br /></td></tr>
<tr class="separator:aba6907846454805fb1cec573aafe65e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536ce5f5409e194a56c006fe8bb3d454" id="r_a536ce5f5409e194a56c006fe8bb3d454"><td class="memItemLeft" align="right" valign="top"><a id="a536ce5f5409e194a56c006fe8bb3d454" name="a536ce5f5409e194a56c006fe8bb3d454"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>comm_backend</b></td></tr>
<tr class="memdesc:a536ce5f5409e194a56c006fe8bb3d454"><td class="mdescLeft">&#160;</td><td class="mdescRight">For session comm/io structures (holds backend instance pointers) <br /></td></tr>
<tr class="separator:a536ce5f5409e194a56c006fe8bb3d454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237458ab782308367b392a36045d1486" id="r_a237458ab782308367b392a36045d1486"><td class="memItemLeft" align="right" valign="top"><a id="a237458ab782308367b392a36045d1486" name="a237458ab782308367b392a36045d1486"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>userdata</b></td></tr>
<tr class="separator:a237458ab782308367b392a36045d1486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ce33227dec019e95821f0ef5c41de9" id="r_ab0ce33227dec019e95821f0ef5c41de9"><td class="memItemLeft" align="right" valign="top"><a id="ab0ce33227dec019e95821f0ef5c41de9" name="ab0ce33227dec019e95821f0ef5c41de9"></a>
pthread_mutex_t *&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b></td></tr>
<tr class="memdesc:ab0ce33227dec019e95821f0ef5c41de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional (see CAMLIB_DONT_USE_MUTEX) <br /></td></tr>
<tr class="separator:ab0ce33227dec019e95821f0ef5c41de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd0410bdf4fe67efe17ddf0937195c4" id="r_adbd0410bdf4fe67efe17ddf0937195c4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbd0410bdf4fe67efe17ddf0937195c4">wait_for_response</a></td></tr>
<tr class="memdesc:adbd0410bdf4fe67efe17ddf0937195c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally wait up to 256 seconds for a response. Some PTP operations require this, such as EOS capture.  <br /></td></tr>
<tr class="separator:adbd0410bdf4fe67efe17ddf0937195c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37501cfcd57c6d29d2201bccfa822d0e" id="r_a37501cfcd57c6d29d2201bccfa822d0e"><td class="memItemLeft" align="right" valign="top"><a id="a37501cfcd57c6d29d2201bccfa822d0e" name="a37501cfcd57c6d29d2201bccfa822d0e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>response_wait_default</b></td></tr>
<tr class="memdesc:a37501cfcd57c6d29d2201bccfa822d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for wait_for_response. <br /></td></tr>
<tr class="separator:a37501cfcd57c6d29d2201bccfa822d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8601b1154a9464a29fa5893b81f87251" id="r_a8601b1154a9464a29fa5893b81f87251"><td class="memItemLeft" align="right" valign="top"><a id="a8601b1154a9464a29fa5893b81f87251" name="a8601b1154a9464a29fa5893b81f87251"></a>
struct <a class="el" href="structPtpPropAvail.html">PtpPropAvail</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>avail</b></td></tr>
<tr class="memdesc:a8601b1154a9464a29fa5893b81f87251"><td class="mdescLeft">&#160;</td><td class="mdescRight">For devices that implement it, this will hold a linked list of properties and an array of their supported values. generic_ functions will reject set property calls if an invalid value is written. <br /></td></tr>
<tr class="separator:a8601b1154a9464a29fa5893b81f87251"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Holds all camlib instance info. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2f65b693efaf4fc67b7837a312dfdd6" name="ac2f65b693efaf4fc67b7837a312dfdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f65b693efaf4fc67b7837a312dfdd6">&#9670;&#160;</a></span>ptp_buffer_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_buffer_resize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mostly for internal use - realloc the data buffer. </p>
<dl class="section note"><dt>Note</dt><dd>r-&gt;data will be reassigned, any old references must be updated </dd></dl>

</div>
</div>
<a id="adc6ae466c463c890efb88a377cb7cf82" name="adc6ae466c463c890efb88a377cb7cf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6ae466c463c890efb88a377cb7cf82">&#9670;&#160;</a></span>ptp_check_opcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_check_opcode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>opcode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an opcode is supported by looking through supported props in r-&gt;di. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if yes, 0 if no </dd></dl>

</div>
</div>
<a id="a593667104ac08ecfba4b8860f83941ec" name="a593667104ac08ecfba4b8860f83941ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593667104ac08ecfba4b8860f83941ec">&#9670;&#160;</a></span>ptp_check_prop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_check_prop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>code</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a property code is supported by looking through supported props in r-&gt;di. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if yes, 0 if no </dd></dl>

</div>
</div>
<a id="af1ec006631ba510bd761704bb6e1603d" name="af1ec006631ba510bd761704bb6e1603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ec006631ba510bd761704bb6e1603d">&#9670;&#160;</a></span>ptp_device_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_device_type </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets type of device from r-&gt;di. </p>
<dl class="section return"><dt>Returns</dt><dd>enum PtpDeviceType </dd></dl>

</div>
</div>
<a id="ae0d253bf202fa9823e1d49fb016f541f" name="ae0d253bf202fa9823e1d49fb016f541f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d253bf202fa9823e1d49fb016f541f">&#9670;&#160;</a></span>ptp_get_all_known()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_get_all_known </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structPtpGenericEvent.html">PtpGenericEvent</a> **</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recieve a generic list of all properties received in DeviceInfo This is similar to getting all events, but for first startup when you know nothing. Some vendors do this, but this gets all the properties manually. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Output structure, caller must free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86c195e74507973ca1a0350686d24b48" name="a86c195e74507973ca1a0350686d24b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c195e74507973ca1a0350686d24b48">&#9670;&#160;</a></span>ptp_get_last_transaction_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_get_last_transaction_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get transaction ID of packet in the data buffer. </p>
<dl class="section note"><dt>Note</dt><dd>Not thread safe. </dd></dl>

</div>
</div>
<a id="acff70238e2dd5babd15b60d030f3febe" name="acff70238e2dd5babd15b60d030f3febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff70238e2dd5babd15b60d030f3febe">&#9670;&#160;</a></span>ptp_get_param()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ptp_get_param </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get parameter at index i. </p>
<dl class="section note"><dt>Note</dt><dd>Not thread safe. </dd></dl>

</div>
</div>
<a id="a34187785d86801a9fb4ccfac95c2b031" name="a34187785d86801a9fb4ccfac95c2b031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34187785d86801a9fb4ccfac95c2b031">&#9670;&#160;</a></span>ptp_get_param_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_get_param_length </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of parameters in packet in data buffer. </p>
<dl class="section note"><dt>Note</dt><dd>Not thread safe. </dd></dl>

</div>
</div>
<a id="a1730ddab297b7c9f0a7619bf4f379571" name="a1730ddab297b7c9f0a7619bf4f379571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1730ddab297b7c9f0a7619bf4f379571">&#9670;&#160;</a></span>ptp_get_partial_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_get_partial_object </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Not thread safe. </dd></dl>

</div>
</div>
<a id="a82fdb25285ca30f1ca7614f416edad13" name="a82fdb25285ca30f1ca7614f416edad13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fdb25285ca30f1ca7614f416edad13">&#9670;&#160;</a></span>ptp_get_payload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * ptp_get_payload </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ptr of packet payload in data buffer, after packet header. </p>
<dl class="section note"><dt>Note</dt><dd>Not thread safe. </dd></dl>

</div>
</div>
<a id="a80bfd0417dabf76cae794215a4189b6c" name="a80bfd0417dabf76cae794215a4189b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bfd0417dabf76cae794215a4189b6c">&#9670;&#160;</a></span>ptp_get_payload_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_get_payload_length </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get length of payload returned by ptp_get_payload. </p>
<dl class="section note"><dt>Note</dt><dd>Not thread safe. </dd></dl>

</div>
</div>
<a id="a4684ca0e83e0459c7d039087f045ef6f" name="a4684ca0e83e0459c7d039087f045ef6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4684ca0e83e0459c7d039087f045ef6f">&#9670;&#160;</a></span>ptp_get_return_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_get_return_code </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the return code (RC) currently in the data buffer. </p>
<dl class="section note"><dt>Note</dt><dd>Not thread safe. </dd></dl>

</div>
</div>
<a id="a1349640be24b23301f82338a4e89202e" name="a1349640be24b23301f82338a4e89202e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1349640be24b23301f82338a4e89202e">&#9670;&#160;</a></span>ptp_get_thumbnail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_get_thumbnail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raw JPEG data is accessible from <a class="el" href="#a82fdb25285ca30f1ca7614f416edad13" title="Get ptr of packet payload in data buffer, after packet header.">ptp_get_payload()</a> </p>
<dl class="section note"><dt>Note</dt><dd>Not thread safe. </dd></dl>

</div>
</div>
<a id="aa24a3ce43b4f53f37731bd03d9735129" name="aa24a3ce43b4f53f37731bd03d9735129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24a3ce43b4f53f37731bd03d9735129">&#9670;&#160;</a></span>ptp_mutex_keep_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ptp_mutex_keep_locked </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep the mutex locked one more time for the current thread. </p>
<dl class="section note"><dt>Note</dt><dd>When calling a thread-safe function, this will garuntee the mutex locked, in the case that you want to continue using the buffer. Must be unlocked or will cause deadlock. </dd>
<dd>
camlib uses a recursive mutex. </dd></dl>

</div>
</div>
<a id="aa317218a1bbbd18bc3b20ae9db1624f9" name="aa317218a1bbbd18bc3b20ae9db1624f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa317218a1bbbd18bc3b20ae9db1624f9">&#9670;&#160;</a></span>ptp_pre_take_picture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_pre_take_picture </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call before taking a picture - this is generally for 'focusing' On some cameras this does nothing. </p>
<dl class="section note"><dt>Note</dt><dd>This is meant for a onMouseDown-like event. ptp_take_picture should be called on onMouseUp </dd></dl>

</div>
</div>
<a id="a14deac23d2f24cc1188c499a1255e5f9" name="a14deac23d2f24cc1188c499a1255e5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14deac23d2f24cc1188c499a1255e5f9">&#9670;&#160;</a></span>ptp_set_generic_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptp_set_generic_property </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a generic property - abstraction over SetDeviceProp. </p>
<dl class="section note"><dt>Note</dt><dd>May reject writes if an invalid property is found (see event code) </dd></dl>

</div>
</div>
<a id="a608fc909a1d17cf3e8ad39b261c994bf" name="a608fc909a1d17cf3e8ad39b261c994bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608fc909a1d17cf3e8ad39b261c994bf">&#9670;&#160;</a></span>ptpip_init_command_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptpip_init_command_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>device_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>PTP/IP only </dd></dl>

</div>
</div>
<a id="aab71c60e32fb92e3c5458431006c57da" name="aab71c60e32fb92e3c5458431006c57da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab71c60e32fb92e3c5458431006c57da">&#9670;&#160;</a></span>ptpip_init_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ptpip_init_events </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structPtpRuntime.html">PtpRuntime</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>PTP/IP only </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aed36a8eae0146cdb13a2fb5e7ca201a0" name="aed36a8eae0146cdb13a2fb5e7ca201a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed36a8eae0146cdb13a2fb5e7ca201a0">&#9670;&#160;</a></span>connection_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PtpRuntime::connection_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One of enum PtpConnType. </p>
<dl class="section note"><dt>Note</dt><dd>Is set to USB by default </dd></dl>

</div>
</div>
<a id="a7f23f0512393ff28362cd8cbf7d7d71e" name="a7f23f0512393ff28362cd8cbf7d7d71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f23f0512393ff28362cd8cbf7d7d71e">&#9670;&#160;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* PtpRuntime::data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global buffer for data reading and writing. </p>
<dl class="section note"><dt>Note</dt><dd>This is volatile - it will grow in size (pointer will change) when needed. </dd></dl>

</div>
</div>
<a id="ad6e7184353de80d51e6f975c7085ffe2" name="ad6e7184353de80d51e6f975c7085ffe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e7184353de80d51e6f975c7085ffe2">&#9670;&#160;</a></span>di</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct PtpDeviceInfo* PtpRuntime::di</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Info about current connection, used to detect camera type, supported opodes, etc. </p>
<dl class="section note"><dt>Note</dt><dd>Set by ptp_parse_device_info. </dd></dl>

</div>
</div>
<a id="aab07e398c60b4ca2c53a84e653a9bdec" name="aab07e398c60b4ca2c53a84e653a9bdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab07e398c60b4ca2c53a84e653a9bdec">&#9670;&#160;</a></span>max_packet_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PtpRuntime::max_packet_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>For optimization on libusb, as many bytes as possible should be read at once. Generally this is 512, but certain comm backends can manage more. For TCP, this isn't used. </dd></dl>

</div>
</div>
<a id="a9e655ea665c46fd29ff029924d63e7fa" name="a9e655ea665c46fd29ff029924d63e7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e655ea665c46fd29ff029924d63e7fa">&#9670;&#160;</a></span>transaction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PtpRuntime::transaction</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The transaction ID and session ID is managed by the packet generator functions </dd></dl>

</div>
</div>
<a id="adbd0410bdf4fe67efe17ddf0937195c4" name="adbd0410bdf4fe67efe17ddf0937195c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd0410bdf4fe67efe17ddf0937195c4">&#9670;&#160;</a></span>wait_for_response</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PtpRuntime::wait_for_response</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optionally wait up to 256 seconds for a response. Some PTP operations require this, such as EOS capture. </p>
<dl class="section note"><dt>Note</dt><dd>Not thread safe. Will be reset after each operation. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>src/<a class="el" href="camlib_8h_source.html">camlib.h</a></li>
<li>src/<a class="el" href="cl__ops_8h_source.html">cl_ops.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
