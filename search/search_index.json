{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Camlib","text":"<p>Camlib is still under heavy development. The API will change and break as I'm using it to develop tools and apps for several different projects.</p> <ul> <li>camlib source code on Github</li> </ul>"},{"location":"#current-applications","title":"Current Applications","text":"<ul> <li>Cam, a better camera controller</li> <li>Fujihack Project</li> <li>mlinstall, Installer for Magic Lantern</li> <li>Fudge, alternative WiFi/Bluetooth app for Fujifilm cameras</li> </ul>"},{"location":"c/","title":"Camlib C API","text":"<p>Camlib uses no macros, so it's easy to use camlib from any language that has a basic C FFI. It would be trivial to write a binding for Rust.</p> <p>Camlib also uses a single-buffer design. This means that all data, whether it comes in or out, is read, written, packed, and unpacked in a single multi-megabyte buffer. This is not done to reduce memory usage, but to decrease complexity and reduce the number of <code>malloc()</code> calls. It also helps prevent rogue memory leaks, which is crucial for apps, which have a very low memory limit.</p> <p>This means that functions processing or using this data must keep the operation mutex locked until processing is done, so long as the caller isn't making the application thread-safe. In a single-threaded application, there is no need for it to be thread-safe.</p> <p>Camlib was designed to run on a single thread, through a thread-safe server returning <code>bind</code> requests. This works well in many applications, but I'm slowly working on making it thread-safe for more complicated appliations.</p>"},{"location":"c/#void-ptp_initstruct-ptpruntime-r","title":"<code>void ptp_init(struct PtpRuntime *r);</code>","text":"<p>Initializes a <code>struct PtpRuntime</code>. The struct is pretty small. This allocates the a large buffer to <code>r.data</code>. You may also set r.connection_type to one of <code>enum PtpConnType</code>.</p>"},{"location":"c/#int-ptp_device_initstruct-ptpruntime-r","title":"<code>int ptp_device_init(struct PtpRuntime *r);</code>","text":"<p>Attempts to connect to the first valid PTP device found, over USB. Returns <code>enum CamlibError</code>.</p>"},{"location":"c/#int-ptp_open_sessionstruct-ptpruntime-r","title":"<code>int ptp_open_session(struct PtpRuntime *r);</code>","text":"<p>Opens session</p>"},{"location":"c/#int-ptp_close_sessionstruct-ptpruntime-r","title":"<code>int ptp_close_session(struct PtpRuntime *r);</code>","text":"<p>Closes session, (typically shuts down camera)</p>"},{"location":"c/#int-ptp_get_device_infostruct-ptpruntime-r-struct-ptpdeviceinfo-di","title":"<code>int ptp_get_device_info(struct PtpRuntime *r, struct PtpDeviceInfo *di);</code>","text":"<p>Recieves device info into <code>struct PtpDeviceInfo</code>.</p>"},{"location":"camlib/","title":"Documentation For Camlib","text":"<ul> <li>Documentation for CamControl scripting</li> </ul>"},{"location":"camlib/#json-bindings","title":"JSON Bindings","text":"<p>Camlib provides a JSON frontend that can easily be ported to higher level programming languages, like Java, Javascript, or Python.</p>"},{"location":"camlib/#bind_run","title":"bind_run","text":"<pre><code>int bind_run(struct PtpRuntime *r, char *req, char *buffer, int max);\n</code></pre> <ul> <li><code>req</code> is a formatted request.</li> <li>Response JSON will be written to <code>buffer</code></li> <li><code>max</code> is the size of the buffer, <code>PTP_BIND_DEFAULT_SIZE</code> is recommended</li> </ul> <p>The formatted request: - Bindings accept a custom format to perform an operation - The end of each section in the request is marked by a <code>;</code> semicolon. - The request starts with an ASCII request name, followed by a semicolon. - For parameters, base 10 numbers or strings seperated by a single <code>,</code> comma follow. - A single string can be submitted, when a parameter is inside <code>\"</code> quotes - The end of the parameters is marked with another <code>;</code> semicolon.</p> <pre><code>ptp_connect;\nptp_drive_lens;-1;\nptp_custom_send;4097,66,66,66,66,66;\nptp_custom_cmd;4097,1,2,3,4,5\nptp_set_property;\"iso\",6400\n</code></pre>"},{"location":"chdk/","title":"CHDK PTP Extension","text":"<ul> <li>Implementation: https://github.com/petabyt/chdk/blob/23c1f3f04fa1c7d483083d403818972a739c6dfd/core/ptp.c#L443</li> <li>Opcode: <code>0x9999</code></li> </ul> <p>All functionality is switched from a code in the first parameter: https://github.com/petabyt/chdk/blob/23c1f3f04fa1c7d483083d403818972a739c6dfd/core/ptp.h#L33C1-L33C1</p>"},{"location":"examples/","title":"Examples","text":"<pre><code>-- Timelapse script\nTAKE_X_PICS = 10\nMS_BETWEEN_PICS = 100\n\nfor i = 0,TAKE_X_PICS,1 do\n    rc = ptp.takePicture()\n\n    if rc == ptp.IO_ERR then\n        setStatusText(\"IO Error taking picture\")\n        break\n    elseif rc == ptp.UNSUPPORTED then\n        setStatusText(\"Remote capture is unsupported\")\n        break\n    elseif rc then\n        setStatusText(\"Error: \" + tostring(rc))\n        break\n    else\n        setStatusText(\"Took \" .. tostring(i) .. \"picture(s)\")\n    end\n\n    msleep(MS_BETWEEN_PICS);\nend\n</code></pre> <pre><code>-- Basic UI script\nwin = ui.popup(\"Astro Mode\")\nif win.addButton(\"Take pic\") then\n    rc = ptp.takePicture()\nendif\n</code></pre>"},{"location":"js/","title":"Camlib.js","text":"<p>The user interface for CamControl is written entirely in HTML/CSS/JS. Requests are made through a JS 'mutex' and routed to camlib bindings. Camlib.js is open-source, you can find it here: https://github.com/clutchlink/camlibjs</p> <p>This is mostly used internally, as every one of these functions require <code>await</code> as they are async. This makes for a clunky and arkward API.</p>"},{"location":"js/#ptpgetdeviceinfo","title":"<code>ptp.getDeviceInfo()</code>","text":"<p>Returns device info as JSON. Note that device info is stored in <code>ptp.info</code> when the device is connected.</p>"},{"location":"js/#ptpdisconnect","title":"<code>ptp.disconnect()</code>","text":"<p>Disconnects the device abruptly. All tasks should die after this.</p>"},{"location":"js/#ptpdrivelens","title":"<code>ptp.driveLens()</code>","text":"<p>Drives the lens, if possible. For EOS cameras, you can use range <code>-3</code>-<code>3</code>.</p>"},{"location":"js/#ptpgetliveviewframe","title":"<code>ptp.getLiveViewFrame()</code>","text":"<p>Internal function used by CamControl (Linux, Windows) to get JSON raw bytes from a liveview frame. This is done internally on the backend.</p>"},{"location":"js/#ptpgetdevicetype","title":"<code>ptp.getDeviceType()</code>","text":"<p>Returns the current device type - type enums are stored in <code>ptp.devs</code>:</p> <pre><code>devs: {\n    EMPTY: 0,\n    EOS: 1,\n    CANON: 2,\n    NIKON: 3,\n    SONY: 4,\n    FUJI: 5,\n    PANASONIC: 6,\n}\n</code></pre>"},{"location":"js/#ptpgetretcode","title":"<code>ptp.getRetCode()</code>","text":"<p>Gets the return code from the last operation.</p>"},{"location":"js/#ptpgetstorageids","title":"<code>ptp.getStorageIDs()</code>","text":"<p>Return a list of storage IDs (32 bit integers) from the camera.</p>"},{"location":"js/#getstorageinfoid","title":"<code>getStorageInfo(id)</code>","text":"<p>Returns a JSON structure with information on the requested storage ID.</p>"},{"location":"js/#ptpgetobjecthandlesid-root","title":"<code>ptp.getObjectHandles(id, root)</code>","text":"<p>Returns a list of object handles from a storage ID. Root can either be 0 for the top directory, or a handle to a folder.</p>"},{"location":"js/#ptpgetobjectinfo","title":"<code>ptp.getObjectInfo()</code>","text":"<p>Gets information on a particular object. Could be a folder, file, or even an album.</p>"},{"location":"js/#ptpgetevents","title":"<code>ptp.getEvents()</code>","text":"<p>Used only by CamControl. Gets a list of changes the camera has made since the last call.</p>"},{"location":"js/#ptpcustomcmdopcode-params","title":"<code>ptp.customCmd(opcode, params)</code>","text":"<p>(Not implemented in v0.1.0) Sends a custom command opcode (with no data phase) to the camera.</p>"},{"location":"js/#ptpgetpartialobjecthandle-offset-max","title":"<code>ptp.getPartialObject(handle, offset, max)</code>","text":"<p>Data is returned in the same way that thumbnail JPEG data is returned.</p>"},{"location":"lua/","title":"Lua API","text":"<p>The Lua API for camlib is under development. You can view the current source code for the bindings here on Github.</p> <p>Currently, the Lua bindings take advantage of the fact that camlib already can convert almost every PTP data structure to JSON - and is able to convert the JSON to Lua tables using <code>lua-cjson</code>.</p>"},{"location":"lua/#ptpgetdeviceinfo","title":"<code>ptp.getDeviceInfo()</code>","text":"<p>Returns a structure about the device:</p> <pre><code>{\n    model = \"Canon Rebel Blah\"\n    propsSupported = {12345, 12345, 12345}\n    ...\n}\n</code></pre>"},{"location":"lua/#ptptakepicture","title":"<code>ptp.takePicture()</code>","text":"<p>Triggers a complete capture.</p>"},{"location":"lua/#ptpsendoperationopcode-params-payload","title":"<code>ptp.sendOperation(opcode, params, payload)</code>","text":"<p>Send a custom opcode request to the camera. Have up to 5 parameters, and an optional payload in bytes (0-255). Only use this if you know what you're doing. Sending bad data can easily brick cameras.</p>"},{"location":"ml/","title":"Magic Lantern PTP Ext (WIP)","text":"<p>Magic Lantern had a custom PTP opcode, (<code>0xA1E8</code>) but it's been left disabled since around 2012. This is a specification for a new opcode extension for ML, using only opcode <code>0x1998</code> (after CHDK's <code>0x9999</code>).</p>"},{"location":"ml/#first-parameter","title":"First Parameter","text":"<pre><code>#define ML_GetExtVersion   0\n#define ML_GetCamInfo      1\n#define ML_SendFileInfo    2\n#define ML_UploadFile      2\n#define ML_GetLiveviewData 3\n#define ML_GetMenuBmpData  4\n#define ML_GetBmpSpecs     5\n</code></pre>"},{"location":"ml/#ml_getextversion","title":"ML_GetExtVersion","text":"<p>Returns <code>uint32_t</code>: version, currently <code>0x00000001</code></p>"},{"location":"ml/#ml_getcaminfo","title":"ML_GetCamInfo","text":"<p>Returns packed struct:</p> <pre><code>struct CamInfo {\n    uint8_t cpu_digic;\n    uint8_t module_api_ver;\n    char build_version[32];\n    char build_id[32];\n    char build_date[32];\n    char build_user[32];\n}\n</code></pre>"},{"location":"ml/#ml_sendfileinfo","title":"ML_SendFileInfo","text":"<p>Similar to <code>SendObjectInfo</code>. Requires data phase from initiator:</p> <pre><code>struct {\n    uint16_t format_code;\n    char filename[32];\n}\n</code></pre>"},{"location":"ml/#ml_uploadfile","title":"ML_UploadFile","text":"<p>Requires data phase from initiator as follows:</p>"},{"location":"ml/#ml_getliveviewdata","title":"ML_GetLiveviewData","text":"<p>Returns unprocessed data stored lvram. Format depends on the DIGIC generation, which can be retrieved from <code>ML_GetExtVersion</code>.</p>"},{"location":"ml/#ml_getmenubmpdata","title":"ML_GetMenuBmpData","text":"<p>Returns unprocessed BMP data - stores both Canon and Magic Lantern menus. Format depends on the DIGIC generation. Each pixel is a single byte. To process this data, <code>ML_GetBmpSpecs</code> must be used to get the width, height, and color palette for each pixel.</p>"},{"location":"ml/#ml_getbmpspecs","title":"ML_GetBmpSpecs","text":"<p>Returns info on how to process the BMP liveview data, starting with info on the pitch and width:</p> <pre><code>struct Info {\n    uint32_t lv_pitch;\n    uint32_t lv_width;\n    uint32_t palette[256];\n}\n</code></pre> <p>The BMP palette tells which each byte (0-256) maps to in RGBA format.</p>"},{"location":"ptp/","title":"Documentation For Camlib","text":"<ul> <li>PDF Reference for PTP and MTP: https://www.usb.org/document-library/media-transfer-protocol-v11-spec-and-mtp-v11-adopters-agreement</li> <li>PTP/IP has no free public reference :(</li> </ul> <p>Terminology: - initiator: the computer that sends commands (laptop, phone, PC) - responder: the computer that responds to commands (the camera)</p>"},{"location":"ptp/#quick-overview-of-ptp-standard","title":"Quick Overview of PTP Standard","text":""},{"location":"ptp/#to-issue-a-command-to-the-device","title":"To issue a command to the device","text":"<ol> <li>Send a command packet with up to 5 parameters</li> <li>An optional data packet (the data phase)</li> <li>A response packet(s) is recieved from the camera.</li> </ol> <p>For data to be sent to the camera, a data packet can be sent following the command packet. The camera should know when to expect this.  </p> <ul> <li>Each packet sent to the camera has a unique transaction ID (see PtpBulkContainer.transaction)</li> <li>The operation code (OC) is an ID for each command, and determines how the camera will expect and send back data.</li> <li>In a response packet, the response code (RC) is placed in the PtpBulkContainer.code field</li> </ul>"},{"location":"ptp/#ptpip","title":"PTP/IP","text":"<p>PTP/IP is the variant of PTP designed to be used on TCP.</p> <p>A standard request to the responder is as follows: 1. Command request (<code>PTPIP_COMMAND_REQUEST</code>) send to responder 2. If sending data payload:     - Set the <code>data_phase</code> field in the initial <code>PTPIP_COMMAND_REQUEST</code> packet     - Send data start packet (<code>PTPIP_DATA_PACKET_START</code>), contains data length     - Send data end packet (<code>PTPIP_DATA_PACKET_END</code>), which includes the actual data 2. If not sending payload to responder, then, wait for response</p> <p>Response is either: - <code>PTPIP_DATA_PACKET_START</code> packet followed by <code>PTPIP_DATA_PACKET_END</code>, and finally a <code>PTPIP_COMMAND_RESPONSE</code> packet - Just a <code>PTPIP_COMMAND_RESPONSE</code> packet</p>"}]}